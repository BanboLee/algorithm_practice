package array

import "fmt"

/*
两个数组的交集
给定两个数组，编写一个函数来计算它们的交集。

示例 1:
输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2]
示例 2:
输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [9,4]

说明:
输出结果中的每个元素一定是唯一的。
我们可以不考虑输出结果的顺序。

分析：
    使用set或map
*/
func intersection(nums1 []int, nums2 []int) []int {
	var m = make(map[int]int)
	var result []int
	for _, n := range nums1 {
		m[n] = 1
	}

	for _, n := range nums2 {
		if m[n] == 1 {
			result = append(result, n)
			m[n] = 2
		}
	}
	return result
}

/*
有效的数独
判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫格内只能出现一次。

数独部分空格内已填入了数字，空白格用 '.' 表示。
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true

输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。

说明:
一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
给定数独序列只包含数字 1-9 和字符 '.' 。
给定数独永远是 9x9 形式的。

分析：
使用set或map
*/
func isValidSudoku(board [][]byte) bool {
	var checker = make(map[string]int)
	for i := range board {
		for j, v := range board[i] {
			if v == '.' {
				continue
			}
			ibr, ibc := i/3, j/3
			ibKey := fmt.Sprintf("ib_%d_%d_%d", ibr, ibc, v)
			if checker[ibKey] != 0 {
				return false
			} else {
				checker[ibKey] = 1
			}

			rKey := fmt.Sprintf("r_%d_%d", i, v)
			if checker[rKey] != 0 {
				return false
			} else {
				checker[rKey] = 1
			}

			cKey := fmt.Sprintf("c_%d_%d", j, v)
			if checker[cKey] != 0 {
				return false
			} else {
				checker[cKey] = 1
			}
		}
	}
	return true
}
